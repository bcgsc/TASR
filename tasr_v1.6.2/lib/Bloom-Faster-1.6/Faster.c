/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Faster.xs. Do not edit this file, edit Faster.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Faster.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <bloom.h>
#include "const-c.inc"
typedef bloom Bloomer;

#line 19 "Faster.c"

/* INCLUDE:  Including 'const-xs.inc' from 'Faster.xs' */


XS(XS_Bloom__Faster_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_constant)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::constant(sv)");
    SP -= items;
    {
#line 4 "const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 43 "Faster.c"
	SV *	sv = ST(0);
	const char *	s = SvPV(sv, len);
#line 18 "const-xs.inc"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid Bloom macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined Bloom macro %s, used", s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing Bloom macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 118 "Faster.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Faster.xs' from 'const-xs.inc' */


XS(XS_Bloom__Faster_binit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_binit)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::binit(size, hashes, capacity, error_rate)");
    {
	unsigned long	size = (unsigned long)SvUV(ST(0));
	int	hashes = (int)SvIV(ST(1));
	unsigned long	capacity = (unsigned long)SvUV(ST(2));
	float	error_rate = (float)SvNV(ST(3));
#line 20 "Faster.xs"
	bloom *newbloom;
#line 141 "Faster.c"
	Bloomer *	RETVAL;
#line 22 "Faster.xs"
	if ((newbloom = (bloom *)malloc(sizeof(bloom))) == NULL) {
		perror("malloc");
	}
	if (bloom_init(newbloom,size,capacity,error_rate,hashes,NULL,0) != 0) {
		RETVAL = NULL;
	} else {
		RETVAL = newbloom;
	}
#line 152 "Faster.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BloomerPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_binit_sugg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_binit_sugg)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::binit_sugg(n, e)");
    {
	char *	n = (char *)SvPV_nolen(ST(0));
	char *	e = (char *)SvPV_nolen(ST(1));
#line 39 "Faster.xs"
	bloom *newbloom;
#line 171 "Faster.c"
	Bloomer *	RETVAL;
#line 41 "Faster.xs"
	struct bloomstat stat;
	unsigned long real_n = atoll(n);
	double real_e = atof(e);

	get_suggestion(&stat,real_n,real_e);
	if ((newbloom = (bloom *)malloc(sizeof(bloom))) == NULL) {
		perror("malloc");
	}
	if (bloom_init(newbloom,stat.elements,real_n,real_e,stat.ideal_hashes,NULL,1) != 0) {
		RETVAL = NULL;
	} else {
		RETVAL = newbloom;
	}
#line 187 "Faster.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BloomerPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_suggestion); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_suggestion)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::suggestion(n, e, m, k)");
    {
	char *	n = (char *)SvPV_nolen(ST(0));
	char *	e = (char *)SvPV_nolen(ST(1));
	SV *	m = ST(2);
	int	k = (int)SvIV(ST(3));
#line 66 "Faster.xs"
	char holder[1000];
	struct bloomstat stat;
	unsigned long real_n = atoll(n);
	double real_e = atof(e);

	get_suggestion(&stat,real_n,real_e);

	sprintf(holder,"%lld",stat.elements);
	m = newSVpvn(holder,strlen(holder));
	k = stat.ideal_hashes;
#line 217 "Faster.c"
	ST(2) = m;
	SvSETMAGIC(ST(2));
	sv_setiv(ST(3), (IV)k);
	SvSETMAGIC(ST(3));
    }
    XSRETURN_EMPTY;
}


XS(XS_Bloom__Faster_bloom_destroyer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_bloom_destroyer)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::bloom_destroyer(newbloom)");
    {
	Bloomer *	newbloom;
#line 84 "Faster.xs"
	bloom *thisbloom;
#line 237 "Faster.c"

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 86 "Faster.xs"
	thisbloom = (bloom *)newbloom;
	bloom_destroy(thisbloom);
	free(thisbloom);
#line 249 "Faster.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bloom__Faster_bcapacity); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_bcapacity)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::bcapacity(newbloom)");
    {
	Bloomer *	newbloom;
#line 94 "Faster.xs"
	bloom *thisbloom;
#line 265 "Faster.c"
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 96 "Faster.xs"
	thisbloom = (bloom *)newbloom;
	RETVAL=thisbloom->stat.capacity;
#line 278 "Faster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_berror_rate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_berror_rate)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::berror_rate(newbloom)");
    {
	Bloomer *	newbloom;
#line 105 "Faster.xs"
	bloom *thisbloom;
#line 295 "Faster.c"
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 107 "Faster.xs"
	thisbloom = (bloom *)newbloom;
	RETVAL=thisbloom->stat.e;
#line 308 "Faster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_belements); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_belements)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::belements(newbloom)");
    {
	Bloomer *	newbloom;
#line 116 "Faster.xs"
	bloom *thisbloom;
#line 325 "Faster.c"
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 118 "Faster.xs"
	thisbloom = (bloom *)newbloom;
	RETVAL=thisbloom->stat.elements;
#line 338 "Faster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_bhash_functions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_bhash_functions)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::bhash_functions(newbloom)");
    {
	Bloomer *	newbloom;
#line 127 "Faster.xs"
	bloom *thisbloom;
#line 355 "Faster.c"
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 129 "Faster.xs"
	thisbloom = (bloom *)newbloom;
	RETVAL=thisbloom->stat.ideal_hashes;
#line 368 "Faster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_binserts); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_binserts)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::binserts(newbloom)");
    {
	Bloomer *	newbloom;
#line 139 "Faster.xs"
	bloom *thisbloom;
#line 385 "Faster.c"
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 141 "Faster.xs"
	thisbloom = (bloom *)newbloom;
	RETVAL = thisbloom->inserts;
#line 398 "Faster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_test_bloom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_test_bloom)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::test_bloom(newbloom, str, mode)");
    {
	Bloomer *	newbloom;
	char *	str = (char *)SvPV_nolen(ST(1));
	int	mode = (int)SvIV(ST(2));
#line 152 "Faster.xs"
	bloom *thisbloom;
#line 417 "Faster.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 154 "Faster.xs"
	thisbloom  = (bloom *)newbloom;
	if (mode == 1) {
		RETVAL = bloom_add(thisbloom,str);
	} else {
		RETVAL = bloom_check(thisbloom,str);
	}
#line 434 "Faster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_bserialize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_bserialize)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::bserialize(newbloom, fname)");
    {
	Bloomer *	newbloom;
	char *	fname = (char *)SvPV_nolen(ST(1));
#line 168 "Faster.xs"
	bloom *thisbloom;
#line 452 "Faster.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 170 "Faster.xs"
	thisbloom  = (bloom *)newbloom;
	if (bloom_serialize(thisbloom,fname) == 0) {
		RETVAL=1;
	} else {
		RETVAL=0;
	}
#line 469 "Faster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_bdeserialize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_bdeserialize)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::bdeserialize(fname)");
    {
	char *	fname = (char *)SvPV_nolen(ST(0));
#line 183 "Faster.xs"
	bloom *newbloom;
#line 486 "Faster.c"
	Bloomer *	RETVAL;
#line 185 "Faster.xs"
	newbloom=bloom_deserialize(fname);
	RETVAL=newbloom;
#line 491 "Faster.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BloomerPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bloom__Faster_get_vector); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bloom__Faster_get_vector)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Bloom::Faster::get_vector(newbloom)");
    {
	Bloomer *	newbloom;
#line 195 "Faster.xs"
		char *other;
#line 509 "Faster.c"
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BloomerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    newbloom = INT2PTR(Bloomer *,tmp);
	}
	else
	    Perl_croak(aTHX_ "newbloom is not of type BloomerPtr");
#line 197 "Faster.xs"
		if ((other = (char *)malloc(sizeof(char) * ((newbloom->stat.elements/8) + 1))) == NULL) {
			perror("malloc");
		}
		strncpy(other,newbloom->vector,(newbloom->stat.elements/8) + 1);
		RETVAL=other;
#line 525 "Faster.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Bloom__Faster); /* prototype to pass -Wmissing-prototypes */
XS(boot_Bloom__Faster)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("Bloom::Faster::constant", XS_Bloom__Faster_constant, file);
        newXS("Bloom::Faster::binit", XS_Bloom__Faster_binit, file);
        newXS("Bloom::Faster::binit_sugg", XS_Bloom__Faster_binit_sugg, file);
        newXSproto("Bloom::Faster::suggestion", XS_Bloom__Faster_suggestion, file, "$$");
        newXS("Bloom::Faster::bloom_destroyer", XS_Bloom__Faster_bloom_destroyer, file);
        newXS("Bloom::Faster::bcapacity", XS_Bloom__Faster_bcapacity, file);
        newXS("Bloom::Faster::berror_rate", XS_Bloom__Faster_berror_rate, file);
        newXS("Bloom::Faster::belements", XS_Bloom__Faster_belements, file);
        newXS("Bloom::Faster::bhash_functions", XS_Bloom__Faster_bhash_functions, file);
        newXS("Bloom::Faster::binserts", XS_Bloom__Faster_binserts, file);
        newXS("Bloom::Faster::test_bloom", XS_Bloom__Faster_test_bloom, file);
        newXS("Bloom::Faster::bserialize", XS_Bloom__Faster_bserialize, file);
        newXS("Bloom::Faster::bdeserialize", XS_Bloom__Faster_bdeserialize, file);
        newXS("Bloom::Faster::get_vector", XS_Bloom__Faster_get_vector, file);
    XSRETURN_YES;
}

